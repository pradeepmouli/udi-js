import ts, { ModifierFlags, type ModifierSyntaxKind, type PunctuationSyntaxKind } from 'typescript';
export declare const SyntaxKind: typeof ts.SyntaxKind;
export type SyntaxKind = ts.SyntaxKind;
export declare class CodeFactory {
    protected factory: ts.NodeFactory;
    constructor(factory: ts.NodeFactory);
    private createIdentifier;
    createImportClause(isTypeOnly: boolean, name?: string, ...namedBindings: ts.NamedImportBindings[]): ts.ImportClause;
    createAssertClause(elements: ts.NodeArray<ts.AssertEntry>, multiLine?: boolean): ts.AssertClause;
    createAssertEntry(name: string, value: ts.Expression): ts.AssertEntry;
    createImportTypeAssertionContainer(clause: ts.AssertClause, multiLine?: boolean): ts.ImportTypeAssertionContainer;
    createImportAttributes(elements: ts.NodeArray<ts.ImportAttribute>, multiLine?: boolean): ts.ImportAttributes;
    createImportAttribute(name: string, value: ts.Expression): ts.ImportAttribute;
    createNamespaceImport(name: string): ts.NamespaceImport;
    createNamespaceExport(name: string): ts.NamespaceExport;
    createNamedImports(...elements: ts.ImportSpecifier[]): ts.NamedImports;
    updateImportClause(node: ts.ImportClause, isTypeOnly: boolean, name?: string, ...namedBindings: ts.NamedImportBindings[]): ts.ImportClause;
    updateAssertClause(node: ts.AssertClause, elements: ts.NodeArray<ts.AssertEntry>, multiLine?: boolean): ts.AssertClause;
    updateAssertEntry(node: ts.AssertEntry, name: string, value: ts.Expression): ts.AssertEntry;
    updateImportTypeAssertionContainer(node: ts.ImportTypeAssertionContainer, clause: ts.AssertClause, multiLine?: boolean): ts.ImportTypeAssertionContainer;
    updateImportAttributes(node: ts.ImportAttributes, elements: ts.NodeArray<ts.ImportAttribute>, multiLine?: boolean): ts.ImportAttributes;
    updateImportAttribute(node: ts.ImportAttribute, name: string, value: ts.Expression): ts.ImportAttribute;
    updateNamespaceImport(node: ts.NamespaceImport, name: string): ts.NamespaceImport;
    updateNamespaceExport(node: ts.NamespaceExport, name: string): ts.NamespaceExport;
    updateNamedImports(node: ts.NamedImports, ...elements: ts.ImportSpecifier[]): ts.NamedImports;
    createImportDeclaration(moduleSpecifier: string, namedImports: string[], isTypeOnly?: boolean, importAttributes?: ts.ImportAttributes, ...modifierFlags: ModifierFlags[]): ts.ImportDeclaration;
    createVariableStatement(name: string, initializer: ts.Expression, isConst?: boolean): ts.VariableStatement;
    createTypeAliasDeclaration(name: string, type: ts.TypeNode): ts.TypeAliasDeclaration;
    createClassDeclaration(name: string, members: ts.ClassElement[], heritageClauses?: ts.HeritageClause[]): ts.ClassDeclaration;
    and<T>(...flags: T[]): T;
    or<T>(...flags: T[]): T;
    createModifiers(...flags: ts.ModifierFlags[]): ts.Modifier[];
    createMethodDeclaration(name: string, parameters: ts.ParameterDeclaration[], body: ts.Block, isAsync?: boolean): ts.MethodDeclaration;
    createPropertyDeclaration(name: string, initializer: ts.Expression, modifiers?: ts.Modifier[]): ts.PropertyDeclaration;
    createConstructorDeclaration(parameters: ts.ParameterDeclaration[], body: ts.Block): ts.ConstructorDeclaration;
    createFunctionDeclaration(name: string, parameters: ts.ParameterDeclaration[], body: ts.Block, returnType?: ts.TypeNode): ts.FunctionDeclaration;
    createModifier(ExportKeyword: ts.ModifierSyntaxKind): ts.ModifierLike;
    createModuleDeclaration(name: string, body: ts.ModuleBlock, ...modifierFlags: ModifierFlags[]): ts.ModuleDeclaration;
    createToken<T extends ModifierSyntaxKind>(kind: T): ts.ModifierLike;
    createToken<T extends PunctuationSyntaxKind>(kind: T): ts.PunctuationToken<T>;
    createPropertySignature(name: string, type: ts.TypeNode, optional?: boolean, ...modifiers: ModifierFlags[]): ts.PropertySignature;
    createTypeReferenceNode(typeName: string, qualifier: string): ts.TypeReferenceNode;
    createTypeReferenceNode(typeName: string, ...typeArguments: ts.TypeNode[]): ts.TypeReferenceNode;
    typesEqual(a: ts.TypeNode, b: ts.TypeNode): boolean;
    createUnionTypeNode(...types: ts.TypeNode[]): ts.UnionTypeNode;
    createIntersectionTypeNode(types: ts.TypeNode[]): ts.IntersectionTypeNode;
    createTypeLiteralNode(members: ts.TypeElement[]): ts.TypeLiteralNode;
    createFunctionTypeNode(type: ts.TypeNode, typeParameters: readonly ts.TypeParameterDeclaration[], ...parameters: ts.ParameterDeclaration[]): ts.FunctionTypeNode;
    createParameter(name: string, type: ts.TypeNode, initializer?: ts.Expression, optional?: boolean): ts.ParameterDeclaration;
    createExpressionStatement(expression: ts.Expression): ts.ExpressionStatement;
    createCallExpression(expression: ts.Expression, typeArguments: ts.TypeNode[] | undefined, argumentsArray: ts.Expression[]): ts.CallExpression;
    createReturnStatement(expression?: ts.Expression): ts.ReturnStatement;
    createNewExpression(expression: ts.Expression, typeArguments: ts.TypeNode[] | undefined, argumentsArray: ts.Expression[]): ts.NewExpression;
    createObjectLiteral(properties: ts.ObjectLiteralElementLike[], multiLine?: boolean): ts.ObjectLiteralExpression;
    createPropertyAssignment(name: string, initializer: ts.Expression): ts.PropertyAssignment;
    createQualifiedName(...names: (ts.EntityName | string)[]): ts.EntityName;
    createLiteralTypeNode(literal: string | number): ts.LiteralTypeNode;
    createLiteral(value: string | number): ts.LiteralExpression | ts.PrefixUnaryExpression;
    createNumericLiteral(value: number, flags?: ts.TokenFlags): ts.NumericLiteral | ts.PrefixUnaryExpression;
    createStringLiteral(text: string): ts.StringLiteral;
    createKeywordTypeNode(kind: ts.KeywordTypeSyntaxKind): ts.KeywordTypeNode;
    createTypePredicateNode(parameterName: ts.Identifier | string, type: ts.TypeNode): ts.TypePredicateNode;
    createBinaryExpression(left: ts.Expression, operator: ts.BinaryOperator, right: ts.Expression): ts.BinaryExpression;
    createPropertyAccessExpression(expression: ts.Expression, name: string | ts.MemberName): ts.PropertyAccessExpression;
    createHeritageClause(token: ts.SyntaxKind.ExtendsKeyword | ts.SyntaxKind.ImplementsKeyword, ...types: ts.ExpressionWithTypeArguments[]): ts.HeritageClause;
    createExpressionWithTypeArguments(expression: ts.Expression, ...typeArguments: ts.TypeNode[]): ts.ExpressionWithTypeArguments;
    createBlock(multiLine: boolean, ...statements: ts.Statement[]): ts.Block;
    createBlock(...statements: ts.Statement[]): any;
    createModuleBlock(...statements: ts.Statement[]): ts.ModuleBlock;
    createInterfaceDeclaration(name: string, members: ts.TypeElement[], heritageClauses?: ts.HeritageClause[]): ts.InterfaceDeclaration;
    createTypeOperatorNode(operator: ts.SyntaxKind.KeyOfKeyword | ts.SyntaxKind.ReadonlyKeyword | ts.SyntaxKind.UniqueKeyword, type: ts.TypeNode): ts.TypeOperatorNode;
    createTypeQueryNode(exprName: ts.EntityName): ts.TypeQueryNode;
    createAsExpression(expression: ts.Expression, type: ts.TypeNode): ts.AsExpression;
    createPropertyAccessChain(name: string, useQuestionDot: boolean, expression: ts.Expression): ts.PropertyAccessChain;
}
//# sourceMappingURL=CodeFactory.d.ts.map